package test;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import telemetry.Cobs;
import telemetry.CobsDecodeException;
import telemetry.RadiationPacket;
import decoder.FoxBitStream;
import decoder.FoxDecoder;

/**
 * 
 * FOX 1 Telemetry Decoder
 * @author chris.e.thompson g0kla/ac2cz
 *
 * Copyright (C) 2015 amsat.org
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
public class CobsTest {

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
	}

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public void test() {
		
		int[] raw = {0x7e,0xe2,0x47,0x5c,0x03,0x1e,0xdd,0x02,0x04,0x7e,0x06,
				0x27,0x5d,0x01,0xa9,0x03,0x7e,0x03,0x17,0x5e,0xe1,0xaa,0xe4,0x1f,0x0d,0x01,0xaa,0xd3,0x7e,0xe2,0x47,0x5f,0xd3,0x02,0x03,0x7e};
		
		int[] raw2 = {0xe2,0x47,0x5c,0x03,0x1e,0xdd,0x02,0x04,0x7e,0x06,
				0x27,0x5d,0x01,0xa9,0x03};
				
		// Corrupt time packet
		int[] time_corrupt = {0x03,0x17,0x5e,0xe1,0xaa,0xe4,0x1f,0x0d,0x01,0xaa,0xd3,0x7e,0xe2,0x47,0x5f,0xd3,0x02,0x03};
		// good time packet
		int[] time = {0x03,0x17,0x54,0xe1,0xa9,0x01,0xe3,0x0a,0x01,0xa8,0xd3};
		
		// corrupt - corrupt_across_two_frames
		int[] corrupt = {0xe2,0x47,0x5c,0xbb,0x02,0x92,0x02,0x92,0xe1,0x92,0x01,0x02,0x04,0x02,0x04,0xe1,0x04,0xdf,0xd3,
				0x11,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46,0x04,0x30,0x31,0x32};
		
		// Good telem packet seq 1877, total mem upsets 0
		int[] input1 = {0xe2,
		0x37,0x55,0xe2,0x01,0xb3,0xe2,0x2a,0x6e,
		0xd6,0xe2,0x01,0xa8,0x01,0xe1,0x03,0x09,
		0x01,0x54,0x02,0xa9,0x02,0x32,0x02,0x30,
		0x02,0xdc,0x02,0x92,0x02,0x92,0xe1,0x92,
		0x01,0x02,0x04,0x02,0x04,0xe1,0x04,0xdf,
		0xd3,0x11,0x00,0x00,0xfc,0x3a,0x00,0x20,
		0x70,0x09,0x38,0x39,0x41,0x42,0x43,0x44,
		0x45,0x46,0x04,0x30,0x31,0x32 };
		
		// Corrupt in a sequence
		int[] input2= {0xe2,0x37,0x56,
				0xe2,0x10,0x2c,0xe2,0x2a,0x6e,0xd6,0xe2,
				0x01,0xa8,0x01,0xe1,0x03,0x09,0x01,0x54,
				0x02,0xa9,0x02,0x33,0x02,0x31,0x02,0xd7,
				0x02,0x92,0x02,0x92,0xe1,0x92,0x01,0x02,
				0x04,0x02,0x00,0x00,0xfc,0x3a,0x00,0x20,
				0x70,0x09,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,
				0x41,0x42,0x43,0x44,0x45,0x46,0x04,0x30,
				0x31,0x32 };
		
		// Good reboot seq 1879
		int[] input3 = {0x06, 0x27, 0x57, 0x01, 0xa8, 0x03};
		
		// Good time packet 1880
		int[] input4 = {0x03,0x17,0x58,0xe1,0xaa,0x01,
		0xe3,0x0a,0x01,0xa9,0xd3};
		
		// Corrupt
		int[] input5 = {0xe2,0x37,
		0x59,0xe2,0x0e,0x51,0xe2,0x2a,0x6e,0xd6,
		0xe2,0x01,0x00,0x00,0xfc,0x3a,0x00,0x20,
		0x70,0x09};
		
		//LEP
		
		int[] input = {	0x0c,0x51,0x38,0xe2,0x58,0x4e,0x01,0xe3,0x38,0x06,0xff,0x01};
		
		int[] inputA = { 0xe2,0x41,0x35,0xd3,0x02,0x03};
		int[] inputB = {		0xe2,
				0x41,0x36,0xe0,0x03,0x01,0x01};
				
		int[] inputC = {		0xe2,0x41,0x37,0xe0,0x03,0x01,0x03};
		
				
		int[] inputD = {		0x09,0x51,0x39,0x06};
		int[] inputE = {		0x28,0x4f,0x1f,0xb4,0x03};

		
		/**
		 * Test packet
		 * E2 - n - E0 databytes + 2 trailing zeros
		 * So we get 2 bytes and 2 zeros
		 * Next byte is 0x03 - 2 data bytes plus 1 zero
		 * So we get 1e d2 00
		 * 01 - no data bytes one zero, which is then truncated as the last zero
		 * Output is therefore 47 5b 00 00 1e d2 00
		 * 
		 */
		int[] state = {0xe2,0x47,0x5b,0x03,0x1e,0xd2,0x01};  // state
		
		/*byte[] bytes = new byte[input.length];
		for (int i : input) {
			bytes[i] = (byte)i;
		}
		*/
		
		//Cobs cobs = new Cobs();
		RadiationPacket packet = new RadiationPacket(1,999);
		
		int[] output = Cobs.unStuffData(input, 256);
		
		for (int i=0; i< output.length; i++) {
			System.out.println(FoxDecoder.hex(output[i]));
		}
		
		
		// print them out in binary first so we can see what is going on
		// This prints msb in the left most position and lsb on the right
		boolean[] w = FoxBitStream.intToBin8(output[0]);
		System.out.println(FoxBitStream.stringBitArray(w));
		w = FoxBitStream.intToBin8(output[1]);
		System.out.println(FoxBitStream.stringBitArray(w));
		w = FoxBitStream.intToBin8(output[2]);
		System.out.println(FoxBitStream.stringBitArray(w));
		w = FoxBitStream.intToBin8(output[3]);
		System.out.println(FoxBitStream.stringBitArray(w));
		

		for (int i=0; i< input.length; i++) {
			packet.addRawByte(input[i]);
		}
		
		try {
			packet.parseRawBytes();
			System.out.println(packet.toString());
		} catch (CobsDecodeException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
		
		
		//boolean[] b = {true, false, false};
		//int field = BitStream.binToInt(b);
		//System.out.println(field);
	}

}
